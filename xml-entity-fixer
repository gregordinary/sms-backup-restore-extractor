import io
import re
import struct

# Per "struct" module docs
UNSIGNED_SHORT = "H"

def shorts_as_utf16(short_sequence):
    if not isinstance(short_sequence, list):
        short_sequence = list(short_sequence)
    format = UNSIGNED_SHORT * (len(short_sequence) + 1)
    # 0xFEFF is a byte-order marker---however it gets encoded by pack(), the
    # UTF-16 decoder is supposed to understand it and use that interpretation
    # for the endianness of the remaining bytes.  We probably don't need it
    # here, but it can't hurt!
    bits = struct.pack(format, 0xFEFF, *short_sequence)
    return bits.decode("UTF-16")

# Numeric XML entities, e.g. "&#55357;&#56860;".
rgx1 = re.compile(r"(?:&#\d+;)+")

# Capture one of the numbers inside an entity
rgx2 = re.compile(r"&#(\d+);")

def fix_codepoints(s, raw=False):
    """Fix malformed XML entities generated by "SMS Backup & Restore".

    Note: this function may break well-formed numeric entities, so be sure that
    the input string does not mix the two.

    Input:
        s -- a string
        raw -- whether to do "raw" conversion (see "Output" below)

    Output:
        The string s, but with bad entities fixed.  If "raw" is True, the bad
        entities are replaced with their actual unicode characters.  If "raw"
        is False, the bad entities are replaced with correct XML entities.

    Details:
        SMS Backup app encodes complicated unicode characters as
          &#XXXXX;&#XXXXX;
        where the two XXX numbers are two unsigned shorts that form a UTF-16
        character.  (Makes sense---it's probably implemented in Java, which
        uses UTF-16 encoding for in-memory strings.)  Proper XML uses unicode
        codepoints (Python's ord()) for the XXX digits, so we need to do
        conversion.
    """

    matches = list(rgx1.finditer(s))
    if not matches:
        return s
    with io.StringIO() as out:
        i = 0
        for m in matches:
            out.write(s[i:m.start()])
            i = m.end()
            repl = shorts_as_utf16(int(i) for i in rgx2.findall(m.group(0)))
            if raw:
                out.write(repl)
            else:
                for c in repl:
                    out.write("&#{};".format(ord(c)))
        out.write(s[i:])
        return out.getvalue()
# Usage description and validate arguments\
if sys.argv.__len__() != 4:
    print("Usage:    python3 <load-all-into-memory> <infile> <outfile>")
    print("")
    print("Example: read line by line, sms.xml and run \"fix_codepoints()\" then save it to fixed.xml")
    print("")
    print("          python3 True sms.xml fixed.xml")
    print("")
    print("Example:  read entire file at once, sms.xml and run \"fix_codepoints()\" then save it to fixed.xml")
    print("")
    print("          python3 False sms.xml fixed.xml")

    exit(1)

# Extract arguments
lineByLine = eval(sys.argv[1])
inputFilePath = sys.argv[2]
outputFilePath = sys.argv[3]

# open files
inputFile = open(inputFilePath, 'r')
outputFile = open(outputFilePath, "w")

lineNum = 0
if lineByLine:
    # process file line by line
    while True:
        rawLine = inputFile.readline()
        lineNum = lineNum + 1

        if rawLine:
            # if we have another line
            sanitizedLine = fix_codepoints(rawLine, raw=True)
            outputFile.write(sanitizedLine)
            print("processing line #", lineNum)

            # flush buffer to disk every 100 lines.
            if lineNum % 100 == 0:
                outputFile.flush()
        else:
            # we reached the end of the file
            break
else:
    # process entire file at once
    rawText = inputFile.read()
    sanitizedText = fix_codepoints(rawText, raw=True)
    outputFile.write(sanitizedText)

outputFile.close()
